<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Group Betting Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Custom Scrollbars */
        textarea::-webkit-scrollbar, #resultsArea::-webkit-scrollbar, .tab-content::-webkit-scrollbar, #calculatedOddsResultContainer::-webkit-scrollbar, .over-under-section div::-webkit-scrollbar {
            width: 8px;
        }
        textarea::-webkit-scrollbar-track, #resultsArea::-webkit-scrollbar-track, .tab-content::-webkit-scrollbar-track, #calculatedOddsResultContainer::-webkit-scrollbar-track, .over-under-section div::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb, #resultsArea::-webkit-scrollbar-thumb, .tab-content::-webkit-scrollbar-thumb, #calculatedOddsResultContainer::-webkit-scrollbar-thumb, .over-under-section div::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        textarea::-webkit-scrollbar-thumb:hover, #resultsArea::-webkit-scrollbar-thumb:hover, .tab-content::-webkit-scrollbar-thumb:hover, #calculatedOddsResultContainer::-webkit-scrollbar-thumb:hover, .over-under-section div::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background-color: #f1f1f1;
            border-radius: 5px 5px 0 0;
            margin-right: 2px;
        }
        .tab-button.active {
            background-color: #fff;
            border-bottom: 1px solid #fff;
            font-weight: bold;
            color: #3b82f6; /* blue-500 */
        }
        .tab-content {
            display: none;
            padding: 20px;
            border: 1px solid #ccc;
            border-top: none;
            background-color: #fff;
            border-radius: 0 0 5px 5px;
        }
        .tab-content.active {
            display: block;
        }
        .odds-table {
            min-width: 100%;
            margin-bottom: 1rem;
        }
        .odds-table th, .odds-table td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        .odds-table th {
            background-color: #f9fafb; /* gray-50 */
        }
        .file-input-button {
            display: inline-block;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
            background-color: #10B981; /* emerald-500 */
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* shadow-sm */
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        .file-input-button:hover {
            background-color: #059669; /* emerald-600 */
        }
        input[type="file"].hidden-file-input {
            display: none;
        }
        .over-under-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
        }
        .over-under-section h5 {
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            color: #4b5563; /* text-gray-600 */
            margin-bottom: 0.5rem;
        }
        .expected-value-info {
            font-size: 0.75rem; /* text-xs */
            font-weight: 400; /* font-normal */
            color: #6b7280; /* text-gray-500 */
            margin-left: 0.5rem;
        }
        .lang-button.active {
            background-color: #3b82f6; /* blue-500 */
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8">
    <div class="container mx-auto max-w-5xl bg-white p-6 rounded-lg shadow-xl relative">
        <header class="mb-6 text-center">
            <h1 id="main-title" class="text-3xl font-bold text-gray-700">Football Competition Analysis Tool</h1>
        </header>
        
        <div class="absolute top-4 right-4 flex space-x-2">
            <button id="langEn" class="lang-button px-3 py-1 text-sm border rounded-md active">EN</button>
            <button id="langSr" class="lang-button px-3 py-1 text-sm border rounded-md">SR</button>
        </div>

        <div class="flex mb-0">
            <button id="tab-btn-simulator" class="tab-button active" onclick="openTab(event, 'simulatorTab')">Group Simulator</button>
            <button id="tab-btn-odds" class="tab-button" onclick="openTab(event, 'oddsCalculatorTab')">Simulated Group Odds</button>
        </div>

        <div id="simulatorTab" class="tab-content active">
            <p id="app-description" class="text-gray-600 mb-4 text-sm">Enter match odds to simulate group outcomes and analyze probabilities. Lambdas are derived using an iterative xG calculation based on O/U and Home/Away odds.</p>
            <div class="mb-4">
                <label for="csvFileInput" id="import-csv-label" class="file-input-button">Import CSV File</label>
                <input type="file" id="csvFileInput" class="hidden-file-input" accept=".csv">
                <span id="csvFileName" class="ml-2 text-sm text-gray-500">No file selected.</span>
                <p id="csv-instructions" class="mt-1 text-xs text-gray-500">
                    CSV Delimiters: comma, semicolon, or tab. Each row a match.<br/>
                    Style 1 (with 'vs'): GROUP,TEAM_A_FIELD(S),vs,TEAM_B_FIELD(S),ODD1,ODDX,ODD2,ODD_U2.5,ODD_O2.5<br/>
                    Style 2 (without 'vs'): GROUP,TEAM_A_FIELD,TEAM_B_FIELD,ODD1,ODDX,ODD2,ODD_U2.5,ODD_O2.5 (TEAM_A/B are single fields)<br/>
                    If team names contain the delimiter, quote them in the CSV (e.g., "Team, Inc.").
                </p>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4">
                <div class="mb-6">
                    <label for="matchData" id="match-data-label" class="block text-sm font-medium text-gray-700 mb-1">Match Data (Odds Input):</label>
                    <textarea id="matchData" rows="10" class="w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Paste match data here or import from CSV. Each line: GROUP TEAM_A vs TEAM_B ODDS_1 ODDS_X ODDS_2 ODDS_UNDER_2.5 ODDS_OVER_2.5&#10;Example: A Al Ahly vs Inter Miami 3.9 3.85 1.85 1.93 1.87"></textarea>
                </div>
                 <div class="mb-6">
                    <label for="liveResultsData" id="live-results-label" class="block text-sm font-medium text-gray-700 mb-1">Live Results (Optional):</label>
                    <textarea id="liveResultsData" rows="10" class="w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Enter one result per line.&#10;Format: Team A X-Y Team B&#10;Example: Germany 5-1 Scotland"></textarea>
                </div>
            </div>
            <div class="mb-6">
                <label for="numSimulations" id="num-sims-label" class="block text-sm font-medium text-gray-700 mb-1">Number of Simulations:</label>
                <input type="number" id="numSimulations" value="10000" class="w-full md:w-1/3 p-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div class="flex flex-col sm:flex-row gap-4 mb-6">
                <button id="parseButton" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 px-4 rounded-md shadow-md transition duration-150 ease-in-out">1. Parse & Validate Data</button>
                <button id="runButton" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-4 rounded-md shadow-md transition duration-150 ease-in-out" disabled>2. Run Simulation</button>
                <button id="clearButton" class="flex-1 bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-4 rounded-md shadow-md transition duration-150 ease-in-out">Clear All</button>
            </div>
            <div id="statusArea" class="mb-4 text-sm text-gray-600"></div>
            <div id="loader" class="loader hidden"></div>
            <div id="resultsArea" class="bg-gray-50 p-4 rounded-md shadow-inner max-h-[70vh] overflow-y-auto">
                <h2 id="sim-results-title" class="text-xl font-semibold text-gray-700 mb-3">Simulation Results:</h2>
                <div id="resultsContent" class="text-sm"> Results will appear here... </div>
            </div>
        </div>

        <div id="oddsCalculatorTab" class="tab-content">
             <h2 id="sim-odds-title" class="text-xl font-semibold text-gray-700 mb-3">Simulated Group Odds</h2>
            <p id="sim-odds-desc" class="text-gray-600 mb-4 text-sm">View odds derived from the simulation results. Select a group and apply a margin.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <div>
                    <label for="simGroupSelect" id="select-group-label" class="block text-sm font-medium text-gray-700 mb-1">Select Group:</label>
                    <select id="simGroupSelect" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="">-- Run Simulation First --</option>
                    </select>
                </div>
                <div>
                    <label for="simBookieMargin" id="bookie-margin-label" class="block text-sm font-medium text-gray-700 mb-1">Main Bookmaker Margin (%):</label>
                    <input type="number" id="simBookieMargin" step="0.1" min="0" value="5" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 5 for 5%">
                </div>
            </div>
            <div class="flex gap-4 mb-4">
                <button id="showSimulatedOddsButton" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-3 px-4 rounded-md shadow-md transition duration-150 ease-in-out">Show/Refresh Market Odds</button>
                <button id="generateGroupCsvButton" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-3 px-4 rounded-md shadow-md transition duration-150 ease-in-out" disabled>Generate Group Odds CSV</button>
            </div>
            <div id="simulatedOddsStatus" class="text-sm text-red-500 mb-4"></div>
            
            <div id="calculatedOddsResultContainer" class="mt-2 p-1 bg-gray-50 rounded-md shadow-inner max-h-[60vh] overflow-y-auto mb-6">
                <div id="calculatedOddsResultContent" class="text-sm"> Select a group and click "Show/Refresh Market Odds" to see standard market results. </div>
            </div>

            <hr class="my-6">
            <h3 id="ou-odds-title" class="text-lg font-semibold text-gray-700 mb-3">Over/Under Line Odds</h3>
            <div class="mb-4">
                 <label for="ouBookieMargin" id="ou-margin-label" class="block text-sm font-medium text-gray-700 mb-1">Over/Under Specific Margin (%):</label>
                 <input type="number" id="ouBookieMargin" step="0.1" min="0" value="5" class="w-full md:w-1/3 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 5 for 5%">
            </div>
            <div id="overUnderMarketsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="over-under-section">
                    <h5><span id="ou-group-goals-title">Total Group Goals O/U</span> <span id="expectedTotalGroupGoals" class="expected-value-info"></span></h5>
                    <div id="ouTotalGroupGoalsResult" class="text-xs"></div>
                </div>
                <div class="over-under-section">
                    <h5><span id="ou-1st-pts-title">Points of 1st Placed Team O/U</span> <span id="expectedFirstPlacePts" class="expected-value-info"></span></h5>
                    <div id="ouFirstPlacePtsResult" class="text-xs"></div>
                </div>
                <div class="over-under-section">
                    <h5><span id="ou-4th-pts-title">Points of 4th Placed Team O/U</span> <span id="expectedFourthPlacePts" class="expected-value-info"></span></h5>
                    <div id="ouFourthPlacePtsResult" class="text-xs"></div>
                </div>
                <div class="over-under-section">
                    <h5><span id="ou-1st-gf-title">Goals For by 1st Placed Team O/U</span> <span id="expectedFirstPlaceGF" class="expected-value-info"></span></h5>
                    <div id="ouFirstPlaceGFResult" class="text-xs"></div>
                </div>
                <div class="over-under-section">
                    <h5><span id="ou-4th-gf-title">Goals For by 4th Placed Team O/U</span> <span id="expectedFourthPlaceGF" class="expected-value-info"></span></h5>
                    <div id="ouFourthPlaceGFResult" class="text-xs"></div>
                </div>
            </div>


            <hr class="my-6">
            <h3 id="custom-props-title" class="text-lg font-semibold text-gray-700 mb-3">Custom Team Prop Odds</h3>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-4">
                <div>
                    <label for="simTeamSelect" id="select-team-label" class="block text-sm font-medium text-gray-700 mb-1">Select Team (from chosen group):</label>
                    <select id="simTeamSelect" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" disabled>
                        <option value="">-- Select Group First --</option>
                    </select>
                </div>
                <div>
                    <button id="generateTeamCsvButton" class="bg-emerald-500 hover:bg-emerald-600 text-white font-semibold py-2 px-4 rounded-md shadow-md transition duration-150 ease-in-out mt-6" disabled>Generate Team CSV</button>
                </div>
            </div>
            <div id="customProbInputsContainer" class="hidden">
                 <div class="flex flex-wrap items-center gap-2 text-sm mb-4 p-3 bg-indigo-50 rounded-md">
                    <span id="calc-prob-prefix" class="font-medium">Calculate P(</span>
                    <select id="simCustomStatType" class="p-1 border rounded text-xs">
                        <option value="ptsSims">Points</option>
                        <option value="winsSims">Wins</option>
                        <option value="gfSims">GF</option>
                        <option value="gaSims">GA</option>
                    </select>
                    <select id="simCustomOperator" class="p-1 border rounded text-xs">
                        <option value=">">&gt;</option><option value=">=">&ge;</option><option value="<">&lt;</option><option value="<=">&le;</option><option value="==">==</option><option value="between">Between</option>
                    </select>
                    <input type="number" step="0.1" id="simCustomValue1" class="p-1 border rounded w-20 text-xs" placeholder="Value 1">
                    <input type="number" step="0.1" id="simCustomValue2" class="p-1 border rounded w-20 text-xs hidden" placeholder="Value 2">
                    <span class="font-medium">)</span>
                    <button id="calculateCustomProbAndOddButton" class="bg-teal-500 hover:bg-teal-600 text-white px-3 py-1 rounded text-xs font-semibold">Calc Prop Odd</button>
                </div>
                <div id="customProbAndOddResultArea" class="text-sm p-3 bg-gray-100 rounded-md"> Custom prop odds will appear here... </div>
            </div>
        </div>
    </div>

    <script>
        // --- Language and Translations ---
        let currentLanguage = 'en';
        const translations = {
            en: {
                'main-title': 'Football Competition Analysis Tool',
                'tab-btn-simulator': 'Group Simulator',
                'tab-btn-odds': 'Simulated Group Odds',
                'app-description': 'Enter match odds to simulate group outcomes and analyze probabilities. Lambdas are derived using an iterative xG calculation based on O/U and Home/Away odds.',
                'import-csv-label': 'Import CSV File',
                'no-file-selected': 'No file selected.',
                'csv-instructions': `CSV Delimiters: comma, semicolon, or tab. Each row a match.<br/>Style 1 (with 'vs'): GROUP,TEAM_A_FIELD(S),vs,TEAM_B_FIELD(S),ODD1,ODDX,ODD2,ODD_U2.5,ODD_O2.5<br/>Style 2 (without 'vs'): GROUP,TEAM_A_FIELD,TEAM_B_FIELD,ODD1,ODDX,ODD2,ODD_U2.5,ODD_O2.5 (TEAM_A/B are single fields)<br/>If team names contain the delimiter, quote them in the CSV (e.g., "Team, Inc.").`,
                'match-data-label': 'Match Data (Odds Input):',
                'match-data-placeholder': `Paste match data here or import from CSV. Each line: GROUP TEAM_A vs TEAM_B ODDS_1 ODDS_X ODDS_2 ODDS_UNDER_2.5 ODDS_OVER_2.5\nExample: A Al Ahly vs Inter Miami 3.9 3.85 1.85 1.93 1.87`,
                'live-results-label': 'Live Results (Optional):',
                'live-results-placeholder': 'Enter one result per line.\nFormat: Team A X-Y Team B\nExample: Germany 5-1 Scotland',
                'num-sims-label': 'Number of Simulations:',
                'parse-btn': '1. Parse & Validate Data',
                'run-btn': '2. Run Simulation',
                'clear-btn': 'Clear All',
                'sim-results-title': 'Simulation Results:',
                'results-placeholder': 'Results will appear here...',
                'sim-odds-title': 'Simulated Group Odds',
                'sim-odds-desc': 'View odds derived from the simulation results. Select a group and apply a margin.',
                'select-group-label': 'Select Group:',
                'run-sim-first-option': '-- Run Simulation First --',
                'select-group-option': '-- Select Group --',
                'bookie-margin-label': 'Main Bookmaker Margin (%):',
                'show-odds-btn': 'Show/Refresh Market Odds',
                'gen-group-csv-btn': 'Generate Group Odds CSV',
                'odds-results-placeholder': 'Select a group and click "Show/Refresh Market Odds" to see standard market results.',
                'ou-odds-title': 'Over/Under Line Odds',
                'ou-margin-label': 'Over/Under Specific Margin (%):',
                'ou-group-goals-title': 'Total Group Goals O/U',
                'ou-1st-pts-title': 'Points of 1st Placed Team O/U',
                'ou-4th-pts-title': 'Points of 4th Placed Team O/U',
                'ou-1st-gf-title': 'Goals For by 1st Placed Team O/U',
                'ou-4th-gf-title': 'Goals For by 4th Placed Team O/U',
                'custom-props-title': 'Custom Team Prop Odds',
                'select-team-label': 'Select Team (from chosen group):',
                'select-group-first-option': '-- Select Group First --',
                'select-team-option': '-- Select Team --',
                'gen-team-csv-btn': 'Generate Team CSV',
                'calc-prob-prefix': 'Calculate P(',
                'calc-prop-odd-btn': 'Calc Prop Odd',
                'custom-odds-placeholder': 'Custom prop odds will appear here...',
                'team': 'Team',
                'e-pts': 'E(Pts)',
                'e-wins': 'E(Wins)',
                'e-gf': 'E(GF)',
                'e-ga': 'E(GA)',
                'p-most-gf': 'P(Most GF)',
                'p-most-ga': 'P(Most GA)',
                'total-group-goals': 'Expected Total Goals in Group',
                'all-sfs': 'All Straight Forecasts (1st-2nd):',
                'top-ads': 'Top Advancing Doubles (Top 2 Any Order):',
                'csv-date': 'Date', 'csv-time': 'Time', 'csv-market': 'Market', 'csv-odd1': 'Odd1', 'csv-odd2': 'Odd2', 'csv-odd3': 'Odd3',
                'csv-group-winner': 'Group Winner', 'csv-qualify': 'To Qualify', 'csv-2nd': '2nd Place', 'csv-3rd': '3rd Place', 'csv-4th': '4th Place',
                'csv-pts-in-group': 'points in group',
                'csv-pts-range-1-3': '1-3 points in group', 'csv-pts-range-2-4': '2-4 points in group', 'csv-pts-range-4-6': '4-6 points in group',
                'csv-total-pts': 'Total points in group',
                'csv-league-name': 'LEAGUE_NAME', 'csv-any-team': 'Any team', 'csv-9-pts': '9 points', 'csv-0-pts': '0 points',
                'csv-total-pts-h': 'Uk. bodova', 'csv-1st-place-team': 'First placed team', 'csv-last-place-team': 'Last placed team',
                'csv-s-forecast': 'Correct Score 1-2', 'csv-adv-doubles': 'First two in group'
            },
            sr: {
                'main-title': 'Alat za Analizu Takmičenja',
                'tab-btn-simulator': 'Simulator Grupa',
                'tab-btn-odds': 'Simulirane Kvote Grupe',
                'app-description': 'Unesite kvote mečeva da simulirate ishode grupe i analizirate verovatnoće. Lambde se izvode pomoću iterativnog xG proračuna na osnovu kvota za Više/Manje i Domaćin/Gost.',
                'import-csv-label': 'Uvezi CSV Fajl',
                'no-file-selected': 'Nije izabran fajl.',
                'csv-instructions': `CSV Delimiteri: zarez, tačka-zarez ili tab. Svaki red jedan meč.<br/>Stil 1 (sa 'vs'): GRUPA,TIM_A,vs,TIM_B,KVOTA1,KVOTAX,KVOTA2,KVOTA_U2.5,KVOTA_O2.5<br/>Stil 2 (bez 'vs'): GRUPA,TIM_A,TIM_B,KVOTA1,KVOTAX,KVOTA2,KVOTA_U2.5,KVOTA_O2.5<br/>Ako imena timova sadrže delimiter, stavite ih pod navodnike (npr. "Tim, Inc.").`,
                'match-data-label': 'Podaci o Mečevima (Unos Kvota):',
                'match-data-placeholder': `Nalepite podatke o mečevima ovde ili ih uvezite iz CSV-a. Svaki red: GRUPA TIM_A vs TIM_B KVOTA_1 KVOTA_X KVOTA_2 KVOTA_ISPOD_2.5 KVOTA_PREKO_2.5\nPrimer: A Srbija vs Engleska 3.9 3.85 1.85 1.93 1.87`,
                'live-results-label': 'Uživo Rezultati (Opciono):',
                'live-results-placeholder': 'Unesite jedan rezultat po redu.\nFormat: Tim A X-Y Tim B\nPrimer: Nemačka 5-1 Škotska',
                'num-sims-label': 'Broj Simulacija:',
                'parse-btn': '1. Parsiraj i Validaraj Podatke',
                'run-btn': '2. Pokreni Simulaciju',
                'clear-btn': 'Obriši Sve',
                'sim-results-title': 'Rezultati Simulacije:',
                'results-placeholder': 'Rezultati će se pojaviti ovde...',
                'sim-odds-title': 'Simulirane Kvote Grupe',
                'sim-odds-desc': 'Pogledajte kvote izvedene iz rezultata simulacije. Izaberite grupu i primenite maržu.',
                'select-group-label': 'Izaberi Grupu:',
                'run-sim-first-option': '-- Prvo Pokreni Simulaciju --',
                'select-group-option': '-- Izaberi Grupu --',
                'bookie-margin-label': 'Glavna Marža Kladionice (%):',
                'show-odds-btn': 'Prikaži/Osveži Tržišne Kvote',
                'gen-group-csv-btn': 'Generiši CSV za Grupu',
                'odds-results-placeholder': 'Izaberite grupu i kliknite na "Prikaži/Osveži Tržišne Kvote" da vidite rezultate.',
                'ou-odds-title': 'Kvote na Više/Manje Golova',
                'ou-margin-label': 'Specifična Marža za Više/Manje (%):',
                'ou-group-goals-title': 'Ukupno Golova u Grupi V/M',
                'ou-1st-pts-title': 'Bodovi Prvoplasiranog Tima V/M',
                'ou-4th-pts-title': 'Bodovi Četvrtoplasiranog Tima V/M',
                'ou-1st-gf-title': 'Datih Golova Prvoplasiranog Tima V/M',
                'ou-4th-gf-title': 'Datih Golova Četvrtoplasiranog Tima V/M',
                'custom-props-title': 'Prilagođene Kvote za Tim',
                'select-team-label': 'Izaberi Tim (iz izabrane grupe):',
                'select-group-first-option': '-- Prvo Izaberi Grupu --',
                'select-team-option': '-- Izaberi Tim --',
                'gen-team-csv-btn': 'Generiši CSV za Tim',
                'calc-prob-prefix': 'Izračunaj P(',
                'calc-prop-odd-btn': 'Izr. Kvotu',
                'custom-odds-placeholder': 'Prilagođene kvote će se pojaviti ovde...',
                'team': 'Tim',
                'e-pts': 'O(Bod)',
                'e-wins': 'O(Pob)',
                'e-gf': 'O(DG)',
                'e-ga': 'O(PG)',
                'p-most-gf': 'V(Najviše DG)',
                'p-most-ga': 'V(Najviše PG)',
                'total-group-goals': 'Očekivano Ukupno Golova u Grupi',
                'all-sfs': 'Svi Tačni Poredci (1.-2.):',
                'top-ads': 'Najbolji Parovi za Prolaz (Top 2 Bilo kojim Redosledom):',
                'csv-date': 'Datum', 'csv-time': 'Vreme', 'csv-market': 'Market', 'csv-odd1': 'Kvota1', 'csv-odd2': 'Kvota2', 'csv-odd3': 'Kvota3',
                'csv-group-winner': 'Pobednik grupe', 'csv-qualify': 'Prolazi grupu', 'csv-2nd': '2. mesto u grupi', 'csv-3rd': '3. mesto u grupi', 'csv-4th': '4. mesto u grupi',
                'csv-pts-in-group': 'bodova u grupi',
                'csv-pts-range-1-3': '1-3 boda u grupi', 'csv-pts-range-2-4': '2-4 boda u grupi', 'csv-pts-range-4-6': '4-6 bodova u grupi',
                'csv-total-pts': 'Osvojenih bodova u grupi',
                'csv-league-name': 'LIGA', 'csv-any-team': 'Bilo koji tim', 'csv-9-pts': '9 bodova', 'csv-0-pts': '0 bodova',
                'csv-total-pts-h': 'Uk. bodova', 'csv-1st-place-team': 'Prvoplasirani tim', 'csv-last-place-team': 'Poslednjeplasirani tim',
                'csv-s-forecast': 'Tacan poredak 1-2', 'csv-adv-doubles': 'Prva dva u grupi'
            }
        };

        function setLanguage(lang) {
            currentLanguage = lang;
            document.querySelectorAll('[id]').forEach(el => {
                const key = el.id;
                if (translations[lang][key]) {
                     if(el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') {
                        if(el.placeholder) el.placeholder = translations[lang][key.replace('-label', '-placeholder')];
                    }
                    el.innerHTML = translations[lang][key];
                }
            });
            
            // Update placeholders separately
            document.getElementById('matchData').placeholder = translations[lang]['match-data-placeholder'];
            document.getElementById('liveResultsData').placeholder = translations[lang]['live-results-placeholder'];


            // Update language button styles
            document.getElementById('langEn').classList.toggle('active', lang === 'en');
            document.getElementById('langSr').classList.toggle('active', lang === 'sr');
            
            // Re-populate dropdowns to update their placeholder text
            populateSimGroupSelect();
        }

        // --- Tab Switching Logic ---
        function openTab(event, tabName) {
            let i, tabcontent, tabbuttons;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove("active");
            }
            tabbuttons = document.getElementsByClassName("tab-button");
            for (i = 0; i < tabbuttons.length; i++) {
                tabbuttons[i].classList.remove("active");
            }
            document.getElementById(tabName).style.display = "block";
            document.getElementById(tabName).classList.add("active");
            event.currentTarget.classList.add("active");
        }
        
        // --- Global Variables ---
        let parsedMatches = [], allTeams = new Set(), groupedMatches = {}, groupTeamNames = {}, simulationAggStats = {}, currentNumSims = 0, liveResults = {};

        // --- DOM Elements ---
        const matchDataEl = document.getElementById('matchData'), liveResultsDataEl = document.getElementById('liveResultsData'), numSimulationsEl = document.getElementById('numSimulations');
        const parseButtonEl = document.getElementById('parseButton'), runButtonEl = document.getElementById('runButton'), clearButtonEl = document.getElementById('clearButton');
        const statusAreaEl = document.getElementById('statusArea'), loaderEl = document.getElementById('loader'), resultsContentEl = document.getElementById('resultsContent');
        const csvFileInputEl = document.getElementById('csvFileInput'), csvFileNameEl = document.getElementById('csvFileName');
        const simGroupSelectEl = document.getElementById('simGroupSelect'), simBookieMarginEl = document.getElementById('simBookieMargin');
        const showSimulatedOddsButtonEl = document.getElementById('showSimulatedOddsButton');
        const calculatedOddsResultContentEl = document.getElementById('calculatedOddsResultContent'), simulatedOddsStatusEl = document.getElementById('simulatedOddsStatus');
        const simTeamSelectEl = document.getElementById('simTeamSelect');
        const customProbInputsContainerEl = document.getElementById('customProbInputsContainer');
        const simCustomStatTypeEl = document.getElementById('simCustomStatType'), simCustomOperatorEl = document.getElementById('simCustomOperator');
        const simCustomValue1El = document.getElementById('simCustomValue1'), simCustomValue2El = document.getElementById('simCustomValue2');
        const calculateCustomProbAndOddButtonEl = document.getElementById('calculateCustomProbAndOddButton');
        const customProbAndOddResultAreaEl = document.getElementById('customProbAndOddResultArea');
        const generateTeamCsvButtonEl = document.getElementById('generateTeamCsvButton'); 
        const generateGroupCsvButtonEl = document.getElementById('generateGroupCsvButton');


        // --- CSV File Input ---
        csvFileInputEl.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                csvFileNameEl.textContent = file.name;
                const reader = new FileReader();
                reader.onload = (e) => { matchDataEl.value = e.target.result; statusAreaEl.innerHTML = `<p class="text-blue-500">CSV loaded. Click "Parse & Validate Data".</p>`; };
                reader.onerror = (e) => { statusAreaEl.innerHTML = `<p class="text-red-500">Error reading file: ${e.target.error.name}</p>`; csvFileNameEl.textContent = "No file selected."; };
                reader.readAsText(file);
            } else { csvFileNameEl.textContent = translations[currentLanguage]['no-file-selected']; }
        });
        
        // --- xG Calculation & Helpers ---
        function factorialJs(n) {
            if (n < 0) return NaN;
            if (n === 0) return 1;
            let result = 1;
            for (let i = 1; i <= n; i++) { result *= i; }
            return result;
        }

        function poissonPMF(mu, k) { 
            if (mu < 0 || k < 0 || !Number.isInteger(k)) return 0;
            if (mu === 0 && k === 0) return 1;
            if (mu === 0 && k > 0) return 0;
            const factK = factorialJs(k);
            if (factK === Infinity || factK === 0) return 0; 
            return (Math.pow(mu, k) * Math.exp(-mu)) / factK;
        }

        function poissonRandom(lambda) { 
            if (lambda <= 0) return 0;
            let L = Math.exp(-lambda);
            let k = 0;
            let p = 1;
            do {
                k++;
                p *= Math.random();
            } while (p > L);
            return k - 1;
        }
        
        function calculateModelProbsFromXG(homeXG, awayXG, goalLine = 2.5) {
            let probHomeWin = 0, probAwayWin = 0, probDraw = 0;
            let probUnder = 0, probOver = 0;
            const maxGoals = 20; 

            for (let i = 0; i <= maxGoals; i++) { 
                for (let j = 0; j <= maxGoals; j++) { 
                    const probScore = poissonPMF(homeXG, i) * poissonPMF(awayXG, j);
                    if (probScore === 0 && !(homeXG === 0 && i === 0 && awayXG === 0 && j === 0) ) continue; 

                    if (i > j) probHomeWin += probScore;
                    else if (j > i) probAwayWin += probScore;
                    else probDraw += probScore;

                    const totalMatchGoals = i + j;
                    if (totalMatchGoals < goalLine) probUnder += probScore;
                    else if (totalMatchGoals > goalLine) probOver += probScore;
                }
            }
            
            const modelProbHomeWinNoDraw = (probHomeWin + probAwayWin > 0) ? probHomeWin / (probHomeWin + probAwayWin) : 0.5; 
            const modelProbUnderNoExact = (probUnder + probOver > 0) ? probUnder / (probUnder + probOver) : 0.5; 
            
            return {
                modelProbHomeWinNoDraw: modelProbHomeWinNoDraw,
                modelProbUnderNoExact: modelProbUnderNoExact,
                probHomeWinFull: probHomeWin, probDrawFull: probDraw, probAwayWinFull: probAwayWin,
                probUnderFull: probUnder, probOverFull: probOver
            };
        }

        function calculateExpectedGoalsFromOdds(overPrice, underPrice, homePrice, awayPrice) {
            const normalisedUnder = (1 / underPrice) / ((1 / overPrice) + (1 / underPrice));
            const normalisedHomeNoDraw = (1 / homePrice) / ((1 / awayPrice) + (1 / homePrice));

            let totalGoals = 2.5; 
            let supremacy = 0;    

            let homeExpectedGoals, awayExpectedGoals;
            let increment;
            let error, previousError;
            let output;
            const maxIterations = 200; 
            const minStep = 0.001; 
            let iterations;

            const updateXGsForTotalGoals = () => {
                homeExpectedGoals = Math.max(0.01, totalGoals / 2 + supremacy / 2);
                awayExpectedGoals = Math.max(0.01, totalGoals / 2 - supremacy / 2);
            };
            
            updateXGsForTotalGoals(); 
            output = calculateModelProbsFromXG(homeExpectedGoals, awayExpectedGoals, 2.5);
            
            increment = (output.modelProbUnderNoExact > normalisedUnder) ? 0.05 : -0.05;

            error = Math.abs(output.modelProbUnderNoExact - normalisedUnder);
            previousError = error + 0.0001; 
            iterations = 0;

            while (error < previousError && iterations < maxIterations && Math.abs(increment) >= minStep) {
                totalGoals += increment;
                totalGoals = Math.max(0.02, totalGoals); 
                updateXGsForTotalGoals();
                
                output = calculateModelProbsFromXG(homeExpectedGoals, awayExpectedGoals, 2.5);
                previousError = error;
                error = Math.abs(output.modelProbUnderNoExact - normalisedUnder);
                
                if (error >= previousError) { 
                    totalGoals -= increment; 
                    increment /= 2; 
                    if(Math.abs(increment) < minStep) break; 
                    totalGoals += increment; 
                    updateXGsForTotalGoals();
                    output = calculateModelProbsFromXG(homeExpectedGoals, awayExpectedGoals, 2.5);
                    error = Math.abs(output.modelProbUnderNoExact - normalisedUnder); 
                }
                iterations++;
            }
             if (error >= previousError && iterations > 0) { 
                totalGoals -= increment; 
             }
             totalGoals = Math.max(0.02, totalGoals);
             updateXGsForTotalGoals();

            output = calculateModelProbsFromXG(homeExpectedGoals, awayExpectedGoals, 2.5); 
            increment = (output.modelProbHomeWinNoDraw > normalisedHomeNoDraw) ? -0.05 : 0.05;
            error = Math.abs(output.modelProbHomeWinNoDraw - normalisedHomeNoDraw);
            previousError = error + 0.0001; 
            iterations = 0;

            const updateXGsForSupremacy = () => {
                supremacy = Math.max(-(totalGoals - 0.02), Math.min(totalGoals - 0.02, supremacy));
                homeExpectedGoals = Math.max(0.01, totalGoals / 2 + supremacy / 2);
                awayExpectedGoals = Math.max(0.01, totalGoals / 2 - supremacy / 2);
            };
            updateXGsForSupremacy();


            while (error < previousError && iterations < maxIterations && Math.abs(increment) >= minStep) {
                supremacy += increment;
                updateXGsForSupremacy();
                
                output = calculateModelProbsFromXG(homeExpectedGoals, awayExpectedGoals, 2.5);
                previousError = error;
                error = Math.abs(output.modelProbHomeWinNoDraw - normalisedHomeNoDraw);

                if (error >= previousError) {
                    supremacy -= increment;
                    increment /= 2;
                    if(Math.abs(increment) < minStep) break;
                    supremacy += increment;
                    updateXGsForSupremacy();
                    output = calculateModelProbsFromXG(homeExpectedGoals, awayExpectedGoals, 2.5);
                    error = Math.abs(output.modelProbHomeWinNoDraw - normalisedHomeNoDraw);
                }
                iterations++;
            }
             if (error >= previousError && iterations > 0) {
                supremacy -= increment;
             }
             updateXGsForSupremacy();

            return { homeXG: homeExpectedGoals, awayXG: awayExpectedGoals };
        }

        // --- Live Results Parsing ---
        function parseLiveResults() {
            liveResults = {};
            const data = liveResultsDataEl.value.trim();
            if (!data) return; // No results to parse

            const lines = data.split('\n');
            let errors = [];

            lines.forEach((line, index) => {
                line = line.trim();
                if (!line) return;
                
                // Regex to find the score (e.g., "2-1" or "0 - 0") and capture teams around it
                const scoreRegex = /^(.*)\s+(\d+)\s*-\s*(\d+)\s+(.*)$/;
                const match = line.match(scoreRegex);

                if (match) {
                    const team1Name = match[1].trim();
                    const score1 = parseInt(match[2], 10);
                    const score2 = parseInt(match[3], 10);
                    const team2Name = match[4].trim();

                    if (!team1Name || !team2Name || isNaN(score1) || isNaN(score2)) {
                        errors.push(`Invalid result format on line ${index + 1}: "${line}"`);
                        return;
                    }
                    
                    // Store result with a sorted key to find it regardless of team order
                    const resultKey = [team1Name, team2Name].sort().join('-');
                    liveResults[resultKey] = { team1: team1Name, g1: score1, g2: score2 };

                } else {
                    errors.push(`Could not parse result on line ${index + 1}: "${line}"`);
                }
            });

            if (errors.length > 0) {
                 statusAreaEl.innerHTML += `<p class="text-red-500 font-semibold mt-2">Live Result Parse Errors:</p><ul class="list-disc list-inside text-red-500">${errors.map(e => `<li>${e}</li>`).join('')}</ul>`;
            } else {
                 statusAreaEl.innerHTML += `<p class="text-green-500">Parsed ${Object.keys(liveResults).length} live results successfully.</p>`;
            }
        }


        // --- Parsing Logic (Simulator) ---
        parseButtonEl.addEventListener('click', () => {
            statusAreaEl.innerHTML = '';
            const data = matchDataEl.value.trim(); if (!data) { statusAreaEl.innerHTML = '<p class="text-red-500">Error: Match data empty.</p>'; return; }
            const lines = data.split('\n'); parsedMatches = []; allTeams.clear(); groupedMatches = {}; groupTeamNames = {};
            let errors = [], warnings = [];
            lines.forEach((line, index) => {
                line = line.trim(); if (!line || line.startsWith('#')) return;
                let parts, isCsvLike = false;
                if (line.includes(',')) { parts = line.split(',').map(p => p.trim()); isCsvLike = true; }
                else if (line.includes(';')) { parts = line.split(';').map(p => p.trim()); isCsvLike = true; }
                else if (line.includes('\t')) { parts = line.split('\t').map(p => p.trim()); isCsvLike = true; }
                else { parts = line.split(/\s+/).map(p => p.trim()); }
                parts = parts.filter(p => p.length > 0);
                let group, team1Name, team2Name, oddsStrings;
                if (isCsvLike) {
                    const vsIdx = parts.map(p => p.toLowerCase()).indexOf('vs');
                    if (vsIdx !== -1) { 
                        if (vsIdx > 0 && vsIdx < parts.length - 5) { group = parts[0]; team1Name = parts.slice(1, vsIdx).join(" "); team2Name = parts.slice(vsIdx + 1, parts.length - 5).join(" "); oddsStrings = parts.slice(parts.length - 5); if (!team1Name || !team2Name) { errors.push(`L${index+1}(CSV 'vs'): Empty T names. L:"${line}"`); return; }}
                        else { errors.push(`L${index+1}(CSV 'vs'): 'vs' wrong pos/few odds. L:"${line}"`); return; }
                    } else { 
                        if (parts.length >= 8) { group = parts[0]; team1Name = parts[1]; team2Name = parts[2]; oddsStrings = parts.slice(3, 8); if (!team1Name || !team2Name) { errors.push(`L${index+1}(CSV no 'vs'): Empty T names. L:"${line}"`); return; }}
                        else { errors.push(`L${index+1}(CSV no 'vs'): <8 cols. Exp G,T1,T2,O1,OX,O2,OU_U,OU_O. Got ${parts.length}. L:"${line}"`); return; }
                    }
                } else { 
                    const vsIdx = parts.map(p => p.toLowerCase()).indexOf('vs');
                    if (vsIdx > 0 && vsIdx < parts.length - 5) { group = parts[0]; team1Name = parts.slice(1, vsIdx).join(" "); team2Name = parts.slice(vsIdx + 1, parts.length - 5).join(" "); oddsStrings = parts.slice(parts.length - 5); if (!team1Name || !team2Name) { errors.push(`L${index+1}(Space): Empty T names. L:"${line}"`); return; }}
                    else { errors.push(`L${index+1}(Space): 'vs' issue/few odds. Exp G T1 vs T2 O1 OX O2 OU_U OU_O. L:"${line}"`); return; }
                }
                if (!oddsStrings || oddsStrings.length !== 5) { errors.push(`L${index+1}: Odds extract fail. Odds:${oddsStrings}. L:"${line}"`); return; }
                const odds = oddsStrings.map(parseFloat);
                if (odds.some(isNaN)) { errors.push(`L${index+1}: Invalid odds. Odds:"${oddsStrings.join(', ')}". L:"${line}"`); return; }
                if (odds.some(o => o <= 0)) { errors.push(`L${index+1}: Odds must be >0. Odds:"${oddsStrings.join(', ')}". L:"${line}"`); return; }
                
                const [o1, ox, o2, oUnder25, oOver25] = odds;

                const sumInv1X2 = (1/o1)+(1/ox)+(1/o2); if (sumInv1X2 === 0) { errors.push(`L${index+1}: Sum inv 1X2 odds 0. L:"${line}"`); return; }
                const p1_market=(1/o1)/sumInv1X2, px_market=(1/ox)/sumInv1X2, p2_market=(1/o2)/sumInv1X2;

                const xGResult = calculateExpectedGoalsFromOdds(oOver25, oUnder25, o1, o2);
                let lambda1 = xGResult.homeXG;
                let lambda2 = xGResult.awayXG;

                if (isNaN(lambda1) || isNaN(lambda2) || lambda1 <=0 || lambda2 <=0) {
                   warnings.push(`L${index+1}: xG calc fail/non-positive for ${team1Name}v${team2Name}. Defaulting. H=${lambda1?.toFixed(2)},A=${lambda2?.toFixed(2)}`);
                   const p_under_fb = (1/oUnder25) / ((1/oOver25) + (1/oUnder25)); 
                   const lt_fb_simple_approx = 2.5; 
                   const s1_fb = p1_market + 0.5 * px_market;
                   const s2_fb = p2_market + 0.5 * px_market;
                   if(s1_fb + s2_fb > 0){
                       lambda1 = lt_fb_simple_approx * s1_fb / (s1_fb + s2_fb);
                       lambda2 = lt_fb_simple_approx * s2_fb / (s1_fb + s2_fb);
                   } else {
                       lambda1 = lt_fb_simple_approx / 2; lambda2 = lt_fb_simple_approx / 2;
                   }
                   lambda1 = Math.max(0.05, lambda1); lambda2 = Math.max(0.05, lambda2);
                }

                const match = { lineNum:index+1, group, team1:team1Name, team2:team2Name, 
                                p1: p1_market, px: px_market, p2: p2_market, 
                                lambda1, lambda2 };
                parsedMatches.push(match); allTeams.add(team1Name); allTeams.add(team2Name);
                if (!groupedMatches[group]) { groupedMatches[group]=[]; groupTeamNames[group]=new Set(); }
                groupedMatches[group].push(match); groupTeamNames[group].add(team1Name); groupTeamNames[group].add(team2Name);
            });
            for (const group in groupTeamNames) {
                if (groupTeamNames[group].size !== 4) warnings.push(`Gr ${group}: ${groupTeamNames[group].size} teams (exp 4).`);
                if (groupedMatches[group] && groupedMatches[group].length !== 6 && groupTeamNames[group].size === 4) warnings.push(`Gr ${group}: ${groupedMatches[group].length} matches (exp 6).`);
                groupTeamNames[group] = Array.from(groupTeamNames[group]);
            }

            parseLiveResults(); // Parse live results after parsing odds data

            if (errors.length > 0) { statusAreaEl.innerHTML += `<p class="text-red-500 font-semibold">Parse Fail (${errors.length}):</p><ul class="list-disc list-inside text-red-500">${errors.map(e=>`<li>${e}</li>`).join('')}</ul>`; if (warnings.length > 0) statusAreaEl.innerHTML += `<p class="text-yellow-600 font-semibold mt-2">Warn (${warnings.length}):</p><ul class="list-disc list-inside text-yellow-600">${warnings.map(w=>`<li>${w}</li>`).join('')}</ul>`; runButtonEl.disabled = true; }
            else { statusAreaEl.innerHTML += `<p class="text-green-500">Parsed ${parsedMatches.length} matches, ${Object.keys(groupedMatches).length} gr, ${allTeams.size} teams.</p>`; if (warnings.length > 0) statusAreaEl.innerHTML += `<p class="text-yellow-600 font-semibold mt-2">Warn (${warnings.length}):</p><ul class="list-disc list-inside text-yellow-600">${warnings.map(w=>`<li>${w}</li>`).join('')}</ul>`; runButtonEl.disabled = false; resultsContentEl.innerHTML = "Parsed. Ready for sim."; }
        });

        // --- Tie-breaking Logic ---
        function tieBreaker(a, b, allTeamsInGroup, matchResults) {
            if (a.pts !== b.pts) return b.pts - a.pts;

            const tiedTeamNames = allTeamsInGroup.filter(t => t.pts === a.pts).map(t => t.name);
            const h2hStats = {};
            tiedTeamNames.forEach(name => { h2hStats[name] = { name, pts: 0, gd: 0, gf: 0 }; });

            matchResults.forEach(match => {
                if (tiedTeamNames.includes(match.team1) && tiedTeamNames.includes(match.team2)) {
                    const team1Stats = h2hStats[match.team1];
                    const team2Stats = h2hStats[match.team2];
                    team1Stats.gf += match.g1;
                    team1Stats.gd += (match.g1 - match.g2);
                    team2Stats.gf += match.g2;
                    team2Stats.gd += (match.g2 - match.g1);
                    if (match.g1 > match.g2) team1Stats.pts += 3;
                    else if (match.g2 > match.g1) team2Stats.pts += 3;
                    else { team1Stats.pts += 1; team2Stats.pts += 1; }
                }
            });

            const statsA = h2hStats[a.name];
            const statsB = h2hStats[b.name];

            if (statsA.pts !== statsB.pts) return statsB.pts - statsA.pts;
            if (statsA.gd !== statsB.gd) return statsB.gd - statsA.gd;
            if (statsA.gf !== statsB.gf) return statsB.gf - statsA.gf;
            if (a.gd !== b.gd) return b.gd - a.gd;
            if (a.gf !== b.gf) return b.gf - a.gf;
            return Math.random() - 0.5;
        }

        // --- Simulation Logic ---
        runButtonEl.addEventListener('click', () => {
            if (parsedMatches.length === 0) { statusAreaEl.innerHTML = '<p class="text-red-500">No data.</p>'; return; }
            currentNumSims = parseInt(numSimulationsEl.value); if (isNaN(currentNumSims) || currentNumSims <= 0) { statusAreaEl.innerHTML = '<p class="text-red-500">Sims > 0.</p>'; return; }
            loaderEl.classList.remove('hidden'); statusAreaEl.innerHTML = `<p class="text-blue-500">Running ${currentNumSims} sims...</p>`;
            resultsContentEl.innerHTML = ""; runButtonEl.disabled = true; parseButtonEl.disabled = true;
            
            setTimeout(() => {
                try {
                    simulationAggStats = runSimulation(currentNumSims);
                    displayResults(simulationAggStats, currentNumSims);
                    populateSimGroupSelect(); 
                    statusAreaEl.innerHTML = `<p class="text-green-500">Sim complete! (${currentNumSims} runs)</p>`;
                } catch (simError) { 
                    console.error("Sim Error:", simError);
                    statusAreaEl.innerHTML = `<p class="text-red-500">Error during simulation: ${simError.message}</p>`;
                    simulationAggStats = {}; 
                    populateSimGroupSelect(); 
                } finally {
                    loaderEl.classList.add('hidden');
                    runButtonEl.disabled = false;
                    parseButtonEl.disabled = false;
                }
            }, 50);
        });

        function runSimulation(numSims) {
            const aggStats={}; 
            for(const gr in groupedMatches){ 
                aggStats[gr]={ groupTotalGoalsSims:[], straightForecasts:{}, advancingDoubles:{}, anyTeam9PtsCount:0, anyTeam0PtsCount:0, firstPlacePtsSims:[], firstPlaceGFSims:[], fourthPlacePtsSims:[], fourthPlaceGFSims:[] }; 
                (groupTeamNames[gr]||[]).forEach(tN=>{ aggStats[gr][tN]={ posCounts:[0,0,0,0], ptsSims:[], gfSims:[], gaSims:[], winsSims: [], mostGFCount:0, mostGACount:0 }; });
            }
            for(let i=0; i<numSims; i++){ 
                for(const gK in groupedMatches){ 
                    const cGMs=groupedMatches[gK];
                    const tIG=[...(groupTeamNames[gK]||[])]; 
                    if(tIG.length===0) continue; 
                    
                    const sTS={}; 
                    tIG.forEach(t=>sTS[t]={name:t,pts:0,gf:0,ga:0,gd:0, wins: 0}); 
                    let cGTG=0;
                    const currentSimMatchResults = [];

                    cGMs.forEach(m=>{
                        const resultKey = [m.team1, m.team2].sort().join('-');
                        let g1, g2;

                        if (liveResults[resultKey]) {
                            const liveResult = liveResults[resultKey];
                            // Ensure scores correspond to the correct team from the match data
                            g1 = (m.team1 === liveResult.team1) ? liveResult.g1 : liveResult.g2;
                            g2 = (m.team1 === liveResult.team1) ? liveResult.g2 : liveResult.g1;
                        } else {
                            g1 = poissonRandom(m.lambda1); 
                            g2 = poissonRandom(m.lambda2);
                        }

                        currentSimMatchResults.push({ team1: m.team1, team2: m.team2, g1, g2 });
                        if(sTS[m.team1]){sTS[m.team1].gf+=g1;sTS[m.team1].ga+=g2;} 
                        if(sTS[m.team2]){sTS[m.team2].gf+=g2;sTS[m.team2].ga+=g1;} 
                        cGTG+=(g1+g2); 
                        if(g1>g2){if(sTS[m.team1]){sTS[m.team1].pts+=3; sTS[m.team1].wins+=1;}}
                        else if(g2>g1){if(sTS[m.team2]){sTS[m.team2].pts+=3; sTS[m.team2].wins+=1;}}
                        else{if(sTS[m.team1])sTS[m.team1].pts+=1;if(sTS[m.team2])sTS[m.team2].pts+=1;}
                    });
            
                    if(aggStats[gK]) aggStats[gK].groupTotalGoalsSims.push(cGTG);
                    
                    const groupStandings = tIG.map(tN => {
                        const s = sTS[tN] || { name: tN, pts: 0, gf: 0, ga: 0, gd: 0, wins: 0 };
                        s.gd = s.gf - s.ga;
                        return s;
                    });
            
                    const rTs = groupStandings.sort((a, b) => tieBreaker(a, b, groupStandings, currentSimMatchResults));
            
                    let mGF=-1,mGA=-1, groupHad9Pts=false, groupHad0Pts=false; 
                    rTs.forEach(t=>{
                        mGF=Math.max(mGF,t.gf); mGA=Math.max(mGA,t.ga); 
                        if(t.pts===9)groupHad9Pts=true; if(t.pts===0)groupHad0Pts=true;
                    }); 
                    if(groupHad9Pts&&aggStats[gK])aggStats[gK].anyTeam9PtsCount++; 
                    if(groupHad0Pts&&aggStats[gK])aggStats[gK].anyTeam0PtsCount++;
            
                    if(rTs.length>0&&aggStats[gK]){ aggStats[gK].firstPlacePtsSims.push(rTs[0].pts); aggStats[gK].firstPlaceGFSims.push(rTs[0].gf); } 
                    if(rTs.length>=4&&aggStats[gK]){ aggStats[gK].fourthPlacePtsSims.push(rTs[3].pts); aggStats[gK].fourthPlaceGFSims.push(rTs[3].gf); }
            
                    rTs.forEach((t,rI)=>{
                        const tA=aggStats[gK]?.[t.name]; 
                        if(tA){
                            if(rI<4)tA.posCounts[rI]++; tA.ptsSims.push(t.pts); tA.winsSims.push(t.wins || 0); tA.gfSims.push(t.gf); tA.gaSims.push(t.ga); 
                            if(t.gf===mGF&&mGF>0)tA.mostGFCount++; if(t.ga===mGA&&mGA>0)tA.mostGACount++;
                        }
                    });
            
                    if(rTs.length>=2&&aggStats[gK]){
                        const sFK=`${rTs[0].name}(1st)-${rTs[1].name}(2nd)`;
                        aggStats[gK].straightForecasts[sFK]=(aggStats[gK].straightForecasts[sFK]||0)+1; 
                        const aDP=[rTs[0].name,rTs[1].name].sort();
                        const aDK=`${aDP[0]}&${aDP[1]}`;
                        aggStats[gK].advancingDoubles[aDK]=(aggStats[gK].advancingDoubles[aDK]||0)+1;
                    }
                }
            }
            return aggStats;
        }

        // --- Display Logic (Simulator) ---
        function displayResults(aggStats, numSims) {
            let html = ''; const sortedGroupKeys = Object.keys(aggStats).sort();
            const lang = currentLanguage;
            for (const groupKey of sortedGroupKeys) {
                const groupData = aggStats[groupKey]; if (!groupData) continue;
                html += `<div class="mb-8 p-4 bg-white border border-gray-200 rounded-lg shadow"><h3 class="text-lg font-semibold text-indigo-600 mb-3">Group ${groupKey}</h3>`;
                const headers = [translations[lang]['team'], translations[lang]['e-pts'], translations[lang]['e-wins'], translations[lang]['e-gf'], translations[lang]['e-ga'], translations[lang]['p-most-gf'], translations[lang]['p-most-ga']];
                html += `<h4 class="font-medium text-gray-700 mt-4 mb-1">${translations[lang]['sim-results-title']}</h4><table class="min-w-full divide-y divide-gray-200 mb-3 text-xs sm:text-sm"><thead class="bg-gray-50"><tr>${headers.map(h=>`<th class="px-2 py-2 text-left font-medium text-gray-500 tracking-wider">${h}</th>`).join('')}</tr></thead><tbody class="bg-white divide-y divide-gray-200">`;
                (groupTeamNames[groupKey]||[]).sort().forEach(teamName=>{const ts=groupData[teamName];if(!ts||!ts.ptsSims)return; const avgPts=(ts.ptsSims.length>0&&numSims>0)?ts.ptsSims.reduce((a,b)=>a+b,0)/numSims:0; const avgWins=(ts.winsSims&&ts.winsSims.length>0&&numSims>0)?ts.winsSims.reduce((a,b)=>a+b,0)/numSims:0; const avgGF=(ts.gfSims.length>0&&numSims>0)?ts.gfSims.reduce((a,b)=>a+b,0)/numSims:0; const avgGA=(ts.gaSims.length>0&&numSims>0)?ts.gaSims.reduce((a,b)=>a+b,0)/numSims:0; html+=`<tr><td class="px-2 py-2 whitespace-nowrap font-medium">${teamName}</td><td class="px-2 py-2">${avgPts.toFixed(2)}</td><td class="px-2 py-2">${avgWins.toFixed(2)}</td><td class="px-2 py-2">${avgGF.toFixed(2)}</td><td class="px-2 py-2">${avgGA.toFixed(2)}</td><td class="px-2 py-2">${(numSims>0?ts.mostGFCount/numSims*100:0).toFixed(1)}%</td><td class="px-2 py-2">${(numSims>0?ts.mostGACount/numSims*100:0).toFixed(1)}%</td></tr>`;});
                html += `</tbody></table>`;
                const avgGroupGoals = (groupData.groupTotalGoalsSims&&groupData.groupTotalGoalsSims.length>0&&numSims>0)?groupData.groupTotalGoalsSims.reduce((a,b)=>a+b,0)/numSims:0;
                html += `<p class="mt-2 text-sm"><strong>${translations[lang]['total-group-goals']} ${groupKey}:</strong> ${avgGroupGoals.toFixed(2)}</p>`;
                const allSF=Object.entries(groupData.straightForecasts||{}).sort(([,a],[,b])=>b-a); html+=`<h4 class="font-medium text-gray-700 mt-4 mb-1">${translations[lang]['all-sfs']}</h4><ul class="list-disc list-inside text-sm max-h-40 overflow-y-auto">${allSF.map(([k,c])=>`<li>${k}: ${(numSims>0?c/numSims*100:0).toFixed(1)}%</li>`).join('')||'N/A'}</ul>`;
                const topAD=Object.entries(groupData.advancingDoubles||{}).sort(([,a],[,b])=>b-a).slice(0,10); html+=`<h4 class="font-medium text-gray-700 mt-4 mb-1">${translations[lang]['top-ads']}</h4><ul class="list-disc list-inside text-sm">${topAD.map(([k,c])=>`<li>${k}: ${(numSims>0?c/numSims*100:0).toFixed(1)}%</li>`).join('')||'N/A'}</ul>`;
                html += `</div>`;
            }
            resultsContentEl.innerHTML = html || `<p>${translations[lang]['results-placeholder']}</p>`;
        }
        
        // --- Simulated Group Odds Tab Logic ---
        function calculateOddWithMargin(trueProb, marginDec) {
            if (trueProb <= 0) return "N/A";
            const fairOdd = 1 / trueProb;
            const bookmakerOdd = fairOdd / (1 + marginDec);
            return bookmakerOdd.toFixed(2);
        }
        
        function populateSimGroupSelect() {
            simGroupSelectEl.innerHTML = `<option value="">${translations[currentLanguage]['select-group-option']}</option>`; 
            simTeamSelectEl.innerHTML = `<option value="">${translations[currentLanguage]['select-group-first-option']}</option>`; 
            simTeamSelectEl.disabled = true; 
            customProbInputsContainerEl.classList.add('hidden');
            if (Object.keys(simulationAggStats).length > 0) { 
                Object.keys(simulationAggStats).sort().forEach(groupKey => { 
                    const option = document.createElement('option'); 
                    option.value = groupKey; 
                    option.textContent = `Group ${groupKey}`; 
                    simGroupSelectEl.appendChild(option); 
                });
            } else { 
                 simGroupSelectEl.innerHTML = `<option value="">${translations[currentLanguage]['run-sim-first-option']}</option>`;
            }
        }

        simGroupSelectEl.addEventListener('change', () => {
            const selectedGroupKey = simGroupSelectEl.value;
            simTeamSelectEl.innerHTML = `<option value="">${translations[currentLanguage]['select-team-option']}</option>`;
            customProbInputsContainerEl.classList.add('hidden'); 
            customProbAndOddResultAreaEl.innerHTML = translations[currentLanguage]['custom-odds-placeholder'];

            if (selectedGroupKey && groupTeamNames[selectedGroupKey]) {
                generateGroupCsvButtonEl.disabled = false;
                groupTeamNames[selectedGroupKey].sort().forEach(teamName => { 
                    const option = document.createElement('option'); 
                    option.value = teamName; 
                    option.textContent = teamName; 
                    simTeamSelectEl.appendChild(option); 
                });
                simTeamSelectEl.disabled = false;
            } else { 
                simTeamSelectEl.disabled = true;
                generateGroupCsvButtonEl.disabled = true;
            }
             ['ouTotalGroupGoalsResult', 'expectedTotalGroupGoals', 'ouFirstPlacePtsResult', 'expectedFirstPlacePts', 'ouFourthPlacePtsResult', 'expectedFourthPlacePts', 'ouFirstPlaceGFResult', 'expectedFirstPlaceGF', 'ouFourthPlaceGFResult', 'expectedFourthPlaceGF'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.innerHTML = '';
             });
        });

        simTeamSelectEl.addEventListener('change', () => {
            if (simTeamSelectEl.value) {
                customProbInputsContainerEl.classList.remove('hidden');
                generateTeamCsvButtonEl.disabled = false;
                customProbAndOddResultAreaEl.innerHTML = "Define prop and click 'Calc Prop Odd'.";
            } else {
                customProbInputsContainerEl.classList.add('hidden');
                generateTeamCsvButtonEl.disabled = true;
            }
        });
        
        showSimulatedOddsButtonEl.addEventListener('click', () => { 
            const selectedGroupKey = simGroupSelectEl.value;
            const mainMarginPercent = parseFloat(simBookieMarginEl.value);
            
            simulatedOddsStatusEl.textContent = ""; 
            calculatedOddsResultContentEl.innerHTML = "";

            if (!selectedGroupKey) { simulatedOddsStatusEl.textContent = "Select group."; return; }
            if (isNaN(mainMarginPercent) || mainMarginPercent < 0 ) { simulatedOddsStatusEl.textContent = "Please enter a valid non-negative margin."; return; }
            if (Object.keys(simulationAggStats).length === 0 || !simulationAggStats[selectedGroupKey] || currentNumSims === 0) { simulatedOddsStatusEl.textContent = "No sim data. Run sim."; return; }
            
            const groupData = simulationAggStats[selectedGroupKey], teams = groupTeamNames[selectedGroupKey] || [];
            if (!groupData || teams.length === 0) { simulatedOddsStatusEl.textContent = "Group data incomplete."; return; }
            
            const mainMarginDecimal = mainMarginPercent / 100;
            let html = `<h3 class="text-lg font-semibold text-purple-600 mb-2">Market Odds for Group ${selectedGroupKey} (Margin: ${mainMarginPercent}%)</h3>`;
            
            html += `<h4 class="font-medium text-gray-700 mt-3 mb-1">Team Standings Odds (1st/2nd/3rd/4th):</h4><table class="odds-table text-xs sm:text-sm"><thead><tr><th>Team</th><th>1st Place</th><th>2nd Place</th><th>3rd Place</th><th>4th Place</th></tr></thead><tbody>`;
            teams.sort().forEach(tN=>{
                html += `<tr><td class="font-medium">${tN}</td>`;
                for(let i = 0; i < 4; i++) {
                    const tS=groupData[tN],tP=(tS&&tS.posCounts&&currentNumSims>0)?(tS.posCounts[i]||0)/currentNumSims:0,o=calculateOddWithMargin(tP,mainMarginDecimal);
                    html += `<td>${o} <span class="text-gray-400">(${(tP*100).toFixed(1)}%)</span></td>`;
                }
                html += `</tr>`;
            });
            html+=`</tbody></table>`;
            
            html += `<h4 class="font-medium text-gray-700 mt-3 mb-1">To Qualify (Top 2):</h4><table class="odds-table text-xs sm:text-sm"><thead><tr><th>Team</th><th>P(Qualify)</th><th>Odd</th></tr></thead><tbody>`;
            teams.sort().forEach(tN=>{const tS=groupData[tN],tP=(tS&&tS.posCounts&&currentNumSims>0)?((tS.posCounts[0]||0)+(tS.posCounts[1]||0))/currentNumSims:0,o=calculateOddWithMargin(tP,mainMarginDecimal);html+=`<tr><td>${tN}</td><td>${(tP*100).toFixed(1)}%</td><td>${o}</td></tr>`;});html+=`</tbody></table>`;

            html += `<h4 class="font-medium text-gray-700 mt-3 mb-1">Team to Score Most Goals:</h4><table class="odds-table text-xs sm:text-sm"><thead><tr><th>Team</th><th>P(Most GF)</th><th>Odd</th></tr></thead><tbody>`;
            teams.sort().forEach(tN=>{const tS=groupData[tN],tP=(tS&&currentNumSims>0)?(tS.mostGFCount||0)/currentNumSims:0,o=calculateOddWithMargin(tP,mainMarginDecimal);html+=`<tr><td>${tN}</td><td>${(tP*100).toFixed(1)}%</td><td>${o}</td></tr>`;});html+=`</tbody></table>`;
            
            html += `<h4 class="font-medium text-gray-700 mt-3 mb-1">Team to Concede Most Goals:</h4><table class="odds-table text-xs sm:text-sm"><thead><tr><th>Team</th><th>P(Most GA)</th><th>Odd</th></tr></thead><tbody>`;
            teams.sort().forEach(tN=>{const tS=groupData[tN],tP=(tS&&currentNumSims>0)?(tS.mostGACount||0)/currentNumSims:0,o=calculateOddWithMargin(tP,mainMarginDecimal);html+=`<tr><td>${tN}</td><td>${(tP*100).toFixed(1)}%</td><td>${o}</td></tr>`;});html+=`</tbody></table>`;

            const allSF = Object.entries(groupData.straightForecasts || {}).sort(([, a], [, b]) => b - a);
            html += `<h4 class="font-medium text-gray-700 mt-3 mb-1">All Straight Forecasts (1st-2nd):</h4>`;
            if (allSF.length > 0) {
                html += `<table class="odds-table text-xs sm:text-sm max-h-60 overflow-y-auto block"><thead><tr><th>Forecast</th><th>Prob</th><th>Odd</th></tr></thead><tbody>`;
                allSF.forEach(([k, c]) => { const tP = currentNumSims > 0 ? c / currentNumSims : 0, o = calculateOddWithMargin(tP, mainMarginDecimal); html += `<tr><td>${k}</td><td>${(tP * 100).toFixed(1)}%</td><td>${o}</td></tr>`; });
                html += `</tbody></table>`;
            } else { html += `<p class="text-xs text-gray-500">No SF data.</p>`; }

            const topAD=Object.entries(groupData.advancingDoubles||{}).sort(([,a],[,b])=>b-a).slice(0,10); html+=`<h4 class="font-medium text-gray-700 mt-3 mb-1">Top Advancing Doubles (Top 2 Any Order):</h4>`; if(topAD.length>0){html+=`<table class="odds-table text-xs sm:text-sm"><thead><tr><th>Pair</th><th>Prob</th><th>Odd</th></tr></thead><tbody>`;topAD.forEach(([k,c])=>{const tP=currentNumSims>0?c/currentNumSims:0,o=calculateOddWithMargin(tP,mainMarginDecimal);html+=`<tr><td>${k}</td><td>${(tP*100).toFixed(1)}%</td><td>${o}</td></tr>`;});html+=`</tbody></table>`;}else{html+=`<p class="text-xs text-gray-500">No AD data.</p>`;}
            
            const probAny9Pts = currentNumSims > 0 ? (groupData.anyTeam9PtsCount || 0) / currentNumSims : 0; const oddAny9Pts = calculateOddWithMargin(probAny9Pts, mainMarginDecimal);
            html += `<h4 class="font-medium text-gray-700 mt-3 mb-1">Group Specials:</h4><table class="odds-table text-xs sm:text-sm"><thead><tr><th>Event</th><th>Prob</th><th>Odd</th></tr></thead><tbody>`;
            html += `<tr><td>Any Team scores 9 Pts</td><td>${(probAny9Pts * 100).toFixed(1)}%</td><td>${oddAny9Pts}</td></tr>`;
            const probAny0Pts = currentNumSims > 0 ? (groupData.anyTeam0PtsCount || 0) / currentNumSims : 0; const oddAny0Pts = calculateOddWithMargin(probAny0Pts, mainMarginDecimal);
            html += `<tr><td>Any Team scores 0 Pts</td><td>${(probAny0Pts * 100).toFixed(1)}%</td><td>${oddAny0Pts}</td></tr></tbody></table>`;

            calculatedOddsResultContentEl.innerHTML = html;

            const displayAvgAndOU = (dataKey, expectedElId, resultElId) => {
                const resultElement = document.getElementById(resultElId);
                const expectedElement = document.getElementById(expectedElId);
                const ouMarginPercent = parseFloat(document.getElementById('ouBookieMargin').value)
                if (isNaN(ouMarginPercent) || ouMarginPercent < 0) return;
                const ouMarginDecimal = ouMarginPercent / 100;

                if (groupData[dataKey] && groupData[dataKey].length > 0 && currentNumSims > 0) {
                    const avg = groupData[dataKey].reduce((a, b) => a + b, 0) / currentNumSims;
                    expectedElement.textContent = `(Avg: ${avg.toFixed(2)})`;

                    const centerLine = Math.round(avg) + 0.5;
                    const lines = [centerLine - 1, centerLine, centerLine + 1].filter(l => l > 0); 
                    let ouHtml = `<table class="w-full text-center"><thead><tr class="text-gray-500"><th class="w-1/3">Line</th><th class="w-1/3">Over</th><th class="w-1/3">Under</th></tr></thead><tbody>`;

                    lines.forEach(line => {
                         const overCount = groupData[dataKey].filter(val => val > line).length;
                         const underCount = groupData[dataKey].filter(val => val < line).length;
                         const probOver = overCount / currentNumSims;
                         const probUnder = underCount / currentNumSims;
                         const oddOver = calculateOddWithMargin(probOver, ouMarginDecimal);
                         const oddUnder = calculateOddWithMargin(probUnder, ouMarginDecimal);
                         ouHtml += `<tr><td>${line.toFixed(1)}</td><td>${oddOver}</td><td>${oddUnder}</td></tr>`;
                    });
                     ouHtml += `</tbody></table>`;
                     resultElement.innerHTML = ouHtml;

                } else {
                     expectedElement.textContent = '';
                     resultElement.innerHTML = '';
                }
            };

            displayAvgAndOU('groupTotalGoalsSims', 'expectedTotalGroupGoals', 'ouTotalGroupGoalsResult');
            displayAvgAndOU('firstPlacePtsSims', 'expectedFirstPlacePts', 'ouFirstPlacePtsResult');
            displayAvgAndOU('fourthPlacePtsSims', 'expectedFourthPlacePts', 'ouFourthPlacePtsResult');
            displayAvgAndOU('firstPlaceGFSims', 'expectedFirstPlaceGF', 'ouFirstPlaceGFResult');
            displayAvgAndOU('fourthPlaceGFSims', 'expectedFourthPlaceGF', 'ouFourthPlaceGFResult');
        });

        calculateCustomProbAndOddButtonEl.addEventListener('click', () => {
            const groupKey = simGroupSelectEl.value;
            const teamName = simTeamSelectEl.value;
            const marginPercent = parseFloat(simBookieMarginEl.value);
            const statType = simCustomStatTypeEl.value;
            const operator = simCustomOperatorEl.value;
            const value1 = parseFloat(simCustomValue1El.value);
            let value2 = null;
            if (operator === 'between') value2 = parseFloat(simCustomValue2El.value);

            customProbAndOddResultAreaEl.innerHTML = ""; 

            if (!groupKey || !teamName) { customProbAndOddResultAreaEl.innerHTML = '<p class="text-red-500">Select group and team.</p>'; return; }
            if (isNaN(marginPercent) || marginPercent < 0) { customProbAndOddResultAreaEl.innerHTML = '<p class="text-red-500">Valid margin needed.</p>'; return; }
            if (isNaN(value1) || (operator === 'between' && isNaN(value2))) { customProbAndOddResultAreaEl.innerHTML = '<p class="text-red-500">Invalid Value(s) for prop.</p>'; return; }
            if (operator === 'between' && value1 >= value2) { customProbAndOddResultAreaEl.innerHTML = '<p class="text-red-500">For "Between", Value 1 must be < Value 2.</p>'; return; }
            
            const teamData = simulationAggStats[groupKey]?.[teamName];
            if (!teamData || !teamData[statType] || !teamData[statType].length || currentNumSims === 0) { customProbAndOddResultAreaEl.innerHTML = '<p class="text-gray-500">No simulation data for this specific prop.</p>'; return; }

            const simValues = teamData[statType];
            let metConditionCount = 0;
            simValues.forEach(simVal => {
                let conditionMet = false;
                switch (operator) {
                    case '>': conditionMet = simVal > value1; break;
                    case '>=': conditionMet = simVal >= value1; break;
                    case '<': conditionMet = simVal < value1; break;
                    case '<=': conditionMet = simVal <= value1; break;
                    case '==': conditionMet = Math.abs(simVal - value1) < 0.001; break;
                    case 'between': conditionMet = simVal >= value1 && simVal <= value2; break;
                }
                if (conditionMet) metConditionCount++;
            });
            
            const trueProbability = metConditionCount / currentNumSims;
            const marginDecimal = marginPercent / 100;
            const odd = calculateOddWithMargin(trueProbability, marginDecimal);

            let propDescription = `${teamName} ${statType.replace('Sims','')} ${operator} ${value1}`;
            if (operator === 'between') propDescription += ` and ${value2}`;

            customProbAndOddResultAreaEl.innerHTML = `
                <p><strong>Prop:</strong> ${propDescription}</p>
                <p><strong>Simulated Probability:</strong> ${(trueProbability * 100).toFixed(1)}%</p>
                <p><strong>Calculated Odd (with ${marginPercent}% margin):</strong> ${odd}</p>`;
        });

        // --- Clear Button ---
        clearButtonEl.addEventListener('click', () => {
            matchDataEl.value = ""; 
            liveResultsDataEl.value = "";
            numSimulationsEl.value = "10000"; 
            statusAreaEl.innerHTML = ""; 
            resultsContentEl.innerHTML = "Results will appear here...";
            parsedMatches=[]; allTeams.clear(); groupedMatches={}; groupTeamNames={}; simulationAggStats={}; currentNumSims=0; liveResults = {};
            runButtonEl.disabled=true; 
            loaderEl.classList.add('hidden'); 
            parseButtonEl.disabled=false;
            csvFileInputEl.value=null; 
            csvFileNameEl.textContent=translations[currentLanguage]['no-file-selected'];
            populateSimGroupSelect(); 
            calculatedOddsResultContentEl.innerHTML = translations[currentLanguage]['odds-results-placeholder'];
            simulatedOddsStatusEl.textContent = "";
            customProbInputsContainerEl.classList.add('hidden');
            customProbAndOddResultAreaEl.innerHTML = translations[currentLanguage]['custom-odds-placeholder'];
             ['ouTotalGroupGoalsResult', 'expectedTotalGroupGoals', 'ouFirstPlacePtsResult', 'expectedFirstPlacePts', 'ouFourthPlacePtsResult', 'expectedFourthPlacePts', 'ouFirstPlaceGFResult', 'expectedFirstPlaceGF', 'ouFourthPlaceGFResult', 'expectedFourthPlaceGF'].forEach(id => {
                 const el = document.getElementById(id);
                 if (el) el.innerHTML = '';
             });
        });

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelector('.tab-button').click();
            document.getElementById('langEn').addEventListener('click', () => setLanguage('en'));
            document.getElementById('langSr').addEventListener('click', () => setLanguage('sr'));
            setLanguage('en'); 
        });

        window.openTab = openTab; 
        simCustomOperatorEl.addEventListener('change', () => { 
            if (simCustomOperatorEl.value === 'between') simCustomValue2El.classList.remove('hidden');
            else simCustomValue2El.classList.add('hidden');
        });

        function downloadCSV(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        generateTeamCsvButtonEl.addEventListener('click', () => {
            const groupKey = simGroupSelectEl.value;
            const teamName = simTeamSelectEl.value;
            const marginPercent = parseFloat(simBookieMarginEl.value);
            const lang = currentLanguage;
            
            if (!groupKey || !teamName) { alert("Please select a group and a team first."); return; }
            if (isNaN(marginPercent) || marginPercent < 0) { alert("Please enter a valid non-negative margin."); return; }

            const teamData = simulationAggStats[groupKey]?.[teamName];
            if (!teamData) { alert("No simulation data found for the selected team."); return; }
            const marginDecimal = marginPercent / 100;

            let csvContent = `${translations[lang]['csv-date']},${translations[lang]['csv-time']},${translations[lang]['csv-market']},${translations[lang]['csv-odd1']},${translations[lang]['csv-odd2']},${translations[lang]['csv-odd3']}\n`;
            const date = "15.6.2025"; const time = "02:00";
            const toCsvRow = (market, odd1 = '', odd2 = '', odd3 = '') => `${date},${time},"${market}",${odd1},${odd2},${odd3}\n`;

            csvContent += toCsvRow(translations[lang]['csv-group-winner'], calculateOddWithMargin((teamData.posCounts[0] || 0) / currentNumSims, marginDecimal));
            csvContent += toCsvRow(translations[lang]['csv-qualify'], calculateOddWithMargin(((teamData.posCounts[0] || 0) + (teamData.posCounts[1] || 0)) / currentNumSims, marginDecimal));
            [1, 2, 3].forEach(i => {
                csvContent += toCsvRow(`${i+1}. ${translations[lang]['csv-2nd'].split(' ')[1]} u grupi`, calculateOddWithMargin((teamData.posCounts[i] || 0) / currentNumSims, marginDecimal));
            });

            const ptsSims = teamData.ptsSims;
            [0,1,2,3,4,5,6,7,9].forEach(pts => {
                const probPts = ptsSims.filter(p => p === pts).length / currentNumSims;
                csvContent += toCsvRow(`${pts} ${translations[lang]['csv-pts-in-group']}`, calculateOddWithMargin(probPts, marginDecimal));
            });

            [
                {label: 'csv-pts-range-1-3', filter: p => p >= 1 && p <= 3},
                {label: 'csv-pts-range-2-4', filter: p => p >= 2 && p <= 4},
                {label: 'csv-pts-range-4-6', filter: p => p >= 4 && p <= 6}
            ].forEach(range => {
                const prob = ptsSims.filter(range.filter).length / currentNumSims;
                csvContent += toCsvRow(translations[lang][range.label], calculateOddWithMargin(prob, marginDecimal));
            });
            
            [5.5, 6.5, 7.5].forEach(line => {
                const overProb = ptsSims.filter(p => p > line).length / currentNumSims;
                const underProb = ptsSims.filter(p => p < line).length / currentNumSims;
                csvContent += toCsvRow(translations[lang]['csv-total-pts'], line, calculateOddWithMargin(overProb, marginDecimal), calculateOddWithMargin(underProb, marginDecimal));
            });
            downloadCSV(csvContent, `odds_${teamName.replace(/\s+/g, '_')}_${lang}.csv`);
        });

        generateGroupCsvButtonEl.addEventListener('click', () => {
            const groupKey = simGroupSelectEl.value;
            const marginPercent = parseFloat(simBookieMarginEl.value);
            const lang = currentLanguage;
            
            if (!groupKey) { alert("Please select a group first."); return; }
            if (isNaN(marginPercent) || marginPercent < 0) { alert("Please enter a valid non-negative margin."); return; }

            const groupData = simulationAggStats[groupKey];
            const teams = groupTeamNames[groupKey] || [];
            if (!groupData || teams.length === 0) { alert("No simulation data found for the selected group."); return; }
            const marginDecimal = marginPercent / 100;

            let csvContent = `${translations[lang]['csv-league-name']}: Grupa ${groupKey}\n`;
            const date = "15.6.2025"; const time = "02:00";
            const toCsvRow = (market, submarket, odd1 = '', odd2 = '', odd3 = '') => `${date},${time},"${market}","${submarket}",${odd1},${odd2},${odd3}\n`;
            
            const addSpecial = (market, submarket, prob) => csvContent += toCsvRow(market, submarket, calculateOddWithMargin(prob, marginDecimal));
            addSpecial(translations[lang]['csv-any-team'], translations[lang]['csv-9-pts'], (groupData.anyTeam9PtsCount || 0) / currentNumSims);
            addSpecial(translations[lang]['csv-any-team'], translations[lang]['csv-0-pts'], (groupData.anyTeam0PtsCount || 0) / currentNumSims);

            const addOUCsv = (sims, submarketKey, lines) => {
                if(sims && sims.length > 0) {
                    lines.forEach(line => {
                        const overProb = sims.filter(p => p > line).length / currentNumSims;
                        const underProb = sims.filter(p => p < line).length / currentNumSims;
                        csvContent += toCsvRow(translations[lang]['csv-total-pts-h'], translations[lang][submarketKey], line, calculateOddWithMargin(overProb, marginDecimal), calculateOddWithMargin(underProb, marginDecimal));
                    });
                }
            };
            addOUCsv(groupData.firstPlacePtsSims, 'csv-1st-place-team', [4.5, 6.5, 7.5]);
            addOUCsv(groupData.fourthPlacePtsSims, 'csv-last-place-team', [0.5, 1.5, 2.5]);

            const processEntries = (entries, marketFn, submarketKey) => {
                 entries.sort(([,a],[,b])=>b-a).forEach(([key, count]) => {
                    const prob = count / currentNumSims;
                    csvContent += toCsvRow(marketFn(key), translations[lang][submarketKey], calculateOddWithMargin(prob, marginDecimal));
                });
            };
            processEntries(Object.entries(groupData.straightForecasts || {}), k => k.replace('(1st)', '').replace('(2nd)', '').replace('-', '/'), 'csv-s-forecast');
            processEntries(Object.entries(groupData.advancingDoubles || {}), k => k.replace(' & ', '/'), 'csv-adv-doubles');

            teams.forEach(team => {
                const prob = (groupData[team].posCounts[0] || 0) / currentNumSims;
                csvContent += toCsvRow(team, translations[lang]['csv-group-winner'], calculateOddWithMargin(prob, marginDecimal));
            });
            downloadCSV(csvContent, `group_odds_${groupKey}_${lang}.csv`);
        });

        // --- Initial Sample Data ---
        matchDataEl.value = `A Germany vs Scotland 1.30 5.50 11.00 2.10 1.70
A Hungary vs Switzerland 3.50 3.20 2.25 1.60 2.30
A Germany vs Hungary 1.30 5.00 10.00 2.30 1.60
A Scotland vs Switzerland 4.50 3.60 1.85 1.70 2.15
A Switzerland vs Germany 5.00 4.00 1.70 2.00 1.80
A Scotland vs Hungary 2.80 3.40 2.50 1.90 1.90
B Spain vs Croatia 1.90 3.40 4.50 1.75 2.10
B Italy vs Albania 1.40 4.50 9.00 1.90 1.90
B Croatia vs Albania 1.50 4.00 7.50 1.80 2.00
B Spain vs Italy 2.20 3.20 3.60 1.65 2.20
B Albania vs Spain 10.00 5.50 1.30 2.00 1.80
B Croatia vs Italy 3.00 3.10 2.60 1.55 2.40`;

    </script>
</body>
</html>
